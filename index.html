<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESMS - Environmental Stress Monitoring System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .panel-title {
            font-size: 1.4em;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stress-indicator {
            text-align: center;
            padding: 40px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .stress-value {
            font-size: 4em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stress-label {
            font-size: 1.8em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stress-low {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        .stress-moderate {
            background: linear-gradient(135deg, #f2994a 0%, #f2c94c 100%);
        }

        .stress-high {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
        }

        .chart-container {
            position: relative;
            min-height: 300px;
        }

        .time-filter {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .time-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .time-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .time-btn.active {
            background: rgba(255, 255, 255, 0.4);
            font-weight: bold;
        }

        .axis {
            font-size: 12px;
        }

        .axis path,
        .axis line {
            stroke: rgba(255, 255, 255, 0.3);
        }

        .axis text {
            fill: white;
        }

        .grid line {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-dasharray: 2,2;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .motion-shade {
            fill: rgba(255, 165, 0, 0.15);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .status-connected {
            background: #38ef7d;
            color: #000;
        }

        .status-disconnected {
            background: #eb3349;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="connection-status status-disconnected" id="status">‚óè Connecting...</div>
    
    <div class="container">
        <header>
            <h1>üå°Ô∏è Environmental Stress Monitoring System</h1>
            <p class="subtitle">Real-Time Sensor Analytics & Stress Index Calculation</p>
        </header>

        <div class="dashboard">
            <!-- Stress Indicator Panel -->
            <div class="panel">
                <div class="panel-title">Stress Index Monitor</div>
                <div class="stress-indicator stress-low" id="stressIndicator">
                    <div class="stress-value" id="stressValue">0.00</div>
                    <div class="stress-label" id="stressLevel">LOW</div>
                </div>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="currentTemp">--</div>
                        <div class="stat-label">Temperature (¬∞C)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="currentHumidity">--</div>
                        <div class="stat-label">Humidity (%)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="currentNoise">--</div>
                        <div class="stat-label">Noise (dB)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="currentHR">--</div>
                        <div class="stat-label">Heart Rate (bpm)</div>
                    </div>
                </div>
            </div>

            <!-- Environmental Time Series -->
            <div class="panel">
                <div class="panel-title">Environmental Parameters</div>
                <div class="time-filter">
                    <button class="time-btn active" data-minutes="1">1 min</button>
                    <button class="time-btn" data-minutes="5">5 min</button>
                    <button class="time-btn" data-minutes="15">15 min</button>
                </div>
                <div class="chart-container" id="timeSeriesChart"></div>
            </div>

            <!-- Correlation Analysis -->
            <div class="panel full-width">
                <div class="panel-title">Heart Rate vs Environmental Factors Correlation</div>
                <div class="chart-container" id="correlationChart"></div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        const API_BASE = 'https://esms.onrender.com:8080';
        
        let currentTimeFilter = 1;
        let allData = [];

        // Update stress indicator
        function updateStressIndicator(data) {
            if (!data || data.length === 0) return;
            
            const latest = data[0];
            const stressValue = latest.stress_index.toFixed(2);
            const stressLevel = latest.stress_level;
            
            document.getElementById('stressValue').textContent = stressValue;
            document.getElementById('stressLevel').textContent = stressLevel.toUpperCase();
            
            const indicator = document.getElementById('stressIndicator');
            indicator.className = 'stress-indicator';
            
            if (stressLevel === 'Low') {
                indicator.classList.add('stress-low');
            } else if (stressLevel === 'Moderate') {
                indicator.classList.add('stress-moderate');
            } else {
                indicator.classList.add('stress-high');
            }

            document.getElementById('currentTemp').textContent = latest.temperature.toFixed(1);
            document.getElementById('currentHumidity').textContent = latest.humidity.toFixed(0);
            document.getElementById('currentNoise').textContent = latest.noise.toFixed(0);
            document.getElementById('currentHR').textContent = latest.heart_rate.toFixed(0);
        }

        // Draw time series chart
        function drawTimeSeries(data) {
            const container = document.getElementById('timeSeriesChart');
            container.innerHTML = '';

            if (data.length === 0) return;

            const margin = {top: 20, right: 80, bottom: 40, left: 60};
            const width = container.clientWidth - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = d3.select('#timeSeriesChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Parse timestamps and reverse for chronological order
            const parseTime = d3.isoParse;
            data.forEach(d => {
                d.parsedTime = parseTime(d.timestamp);
            });
            data.reverse();

            // Scales
            const x = d3.scaleTime()
                .domain(d3.extent(data, d => d.parsedTime))
                .range([0, width]);

            const yTemp = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.temperature) * 1.1])
                .range([height, 0]);

            const yHumidity = d3.scaleLinear()
                .domain([0, 100])
                .range([height, 0]);

            const yNoise = d3.scaleLinear()
                .domain([0, 100])
                .range([height, 0]);

            // Motion periods shading
            let motionPeriods = [];
            let motionStart = null;
            data.forEach((d, i) => {
                if (d.motion && !motionStart) {
                    motionStart = d.parsedTime;
                } else if (!d.motion && motionStart) {
                    motionPeriods.push([motionStart, data[i-1].parsedTime]);
                    motionStart = null;
                }
            });
            if (motionStart) {
                motionPeriods.push([motionStart, data[data.length-1].parsedTime]);
            }

            motionPeriods.forEach(period => {
                svg.append('rect')
                    .attr('class', 'motion-shade')
                    .attr('x', x(period[0]))
                    .attr('y', 0)
                    .attr('width', x(period[1]) - x(period[0]))
                    .attr('height', height);
            });

            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .attr('opacity', 0.1)
                .call(d3.axisLeft(yTemp).tickSize(-width).tickFormat(''));

            // Lines
            const tempLine = d3.line()
                .x(d => x(d.parsedTime))
                .y(d => yTemp(d.temperature));

            const humidityLine = d3.line()
                .x(d => x(d.parsedTime))
                .y(d => yHumidity(d.humidity));

            const noiseLine = d3.line()
                .x(d => x(d.parsedTime))
                .y(d => yNoise(d.noise));

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#ff6b6b')
                .attr('stroke-width', 2)
                .attr('d', tempLine);

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#4ecdc4')
                .attr('stroke-width', 2)
                .attr('d', humidityLine);

            svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#ffe66d')
                .attr('stroke-width', 2)
                .attr('d', noiseLine);

            // Axes
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(5));

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(yTemp));

            // Legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 70}, 10)`);

            ['Temperature', 'Humidity', 'Noise'].forEach((label, i) => {
                const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
                legend.append('rect')
                    .attr('x', 0)
                    .attr('y', i * 20)
                    .attr('width', 15)
                    .attr('height', 2)
                    .attr('fill', colors[i]);
                
                legend.append('text')
                    .attr('x', 20)
                    .attr('y', i * 20 + 5)
                    .attr('fill', 'white')
                    .style('font-size', '11px')
                    .text(label);
            });

            // Tooltip interaction
            const tooltip = d3.select('#tooltip');
            const bisect = d3.bisector(d => d.parsedTime).left;

            const focus = svg.append('g').style('display', 'none');
            focus.append('line')
                .attr('stroke', 'white')
                .attr('stroke-dasharray', '3,3')
                .attr('y1', 0)
                .attr('y2', height);

            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', () => focus.style('display', null))
                .on('mouseout', () => {
                    focus.style('display', 'none');
                    tooltip.style('display', 'none');
                })
                .on('mousemove', function(event) {
                    const x0 = x.invert(d3.pointer(event, this)[0]);
                    const i = bisect(data, x0, 1);
                    const d = data[i];
                    if (!d) return;

                    focus.select('line')
                        .attr('x1', x(d.parsedTime))
                        .attr('x2', x(d.parsedTime));

                    tooltip.html(`
                        <strong>${new Date(d.timestamp).toLocaleTimeString()}</strong><br/>
                        Temperature: ${d.temperature.toFixed(1)}¬∞C<br/>
                        Humidity: ${d.humidity.toFixed(0)}%<br/>
                        Noise: ${d.noise.toFixed(0)} dB<br/>
                        Motion: ${d.motion ? 'Yes' : 'No'}
                    `)
                    .style('display', 'block')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                });
        }

        // Draw correlation chart
        function drawCorrelation(data) {
            const container = document.getElementById('correlationChart');
            container.innerHTML = '';

            if (data.length === 0) return;

            const margin = {top: 20, right: 20, bottom: 60, left: 60};
            const width = container.clientWidth - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = d3.select('#correlationChart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Prepare data
            const scatterData = data.flatMap(d => [
                {x: d.temperature, y: d.heart_rate, type: 'temp', motion: d.motion, stress: d.stress_index},
                {x: d.humidity, y: d.heart_rate, type: 'humidity', motion: d.motion, stress: d.stress_index},
                {x: d.noise, y: d.heart_rate, type: 'noise', motion: d.motion, stress: d.stress_index}
            ]);

            // Scales
            const x = d3.scaleLinear()
                .domain([0, 100])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([50, d3.max(scatterData, d => d.y) * 1.1])
                .range([height, 0]);

            const color = d3.scaleOrdinal()
                .domain(['temp', 'humidity', 'noise'])
                .range(['#ff6b6b', '#4ecdc4', '#ffe66d']);

            // Grid
            svg.append('g')
                .attr('class', 'grid')
                .attr('opacity', 0.1)
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));

            // Points
            svg.selectAll('circle')
                .data(scatterData.filter(d => !d.motion))
                .enter()
                .append('circle')
                .attr('cx', d => x(d.x))
                .attr('cy', d => y(d.y))
                .attr('r', d => d.stress > 0.6 ? 6 : 4)
                .attr('fill', d => color(d.type))
                .attr('opacity', d => d.stress > 0.6 ? 0.9 : 0.6)
                .attr('stroke', d => d.stress > 0.6 ? 'white' : 'none')
                .attr('stroke-width', 2);

            // Axes
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            svg.append('text')
                .attr('transform', `translate(${width/2},${height + 40})`)
                .style('text-anchor', 'middle')
                .attr('fill', 'white')
                .text('Environmental Factor Value');

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -40)
                .attr('x', -height/2)
                .style('text-anchor', 'middle')
                .attr('fill', 'white')
                .text('Heart Rate (bpm)');

            // Legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 100}, 10)`);

            ['Temperature', 'Humidity', 'Noise'].forEach((label, i) => {
                const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d'];
                legend.append('circle')
                    .attr('cx', 7)
                    .attr('cy', i * 20 + 7)
                    .attr('r', 5)
                    .attr('fill', colors[i]);
                
                legend.append('text')
                    .attr('x', 20)
                    .attr('y', i * 20 + 11)
                    .attr('fill', 'white')
                    .style('font-size', '11px')
                    .text(label);
            });
        }

        // Fetch and update data
        async function fetchData() {
            try {
                const response = await fetch(`${API_BASE}/api/realtime`);
                if (!response.ok) throw new Error('Failed to fetch');
                
                const data = await response.json();
                allData = data;
                
                document.getElementById('status').textContent = '‚óè Connected';
                document.getElementById('status').className = 'connection-status status-connected';
                
                updateStressIndicator(data);
                
                const cutoffTime = new Date(Date.now() - currentTimeFilter * 60 * 1000);
                const filteredData = data.filter(d => new Date(d.timestamp) >= cutoffTime);
                
                drawTimeSeries(filteredData);
                drawCorrelation(filteredData);
                
            } catch (error) {
                console.error('Error fetching data:', error);
                document.getElementById('status').textContent = '‚óè Disconnected';
                document.getElementById('status').className = 'connection-status status-disconnected';
            }
        }

        // Time filter buttons
        document.querySelectorAll('.time-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentTimeFilter = parseInt(this.dataset.minutes);
                fetchData();
            });
        });

        // Start polling
        fetchData();
        setInterval(fetchData, 1000);
    </script>
</body>
</html>